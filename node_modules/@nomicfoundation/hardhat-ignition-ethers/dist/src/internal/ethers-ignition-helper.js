import "@nomicfoundation/hardhat-ethers";
import "@nomicfoundation/hardhat-ignition";
import path from "node:path";
import { HardhatError, assertHardhatInvariant, } from "@nomicfoundation/hardhat-errors";
import { HardhatArtifactResolver, PrettyEventHandler, errorDeploymentResultToExceptionMessage, readDeploymentParameters, resolveDeploymentId, } from "@nomicfoundation/hardhat-ignition/helpers";
import { DeploymentResultType, deploy, isContractFuture, } from "@nomicfoundation/ignition-core";
export class EthersIgnitionHelperImpl {
    type = "ethers";
    #hardhatConfig;
    #artifactsManager;
    #connection;
    #config;
    #provider;
    #mutex = false;
    constructor(hardhatConfig, artifactsManager, connection, config, provider) {
        this.#hardhatConfig = hardhatConfig;
        this.#artifactsManager = artifactsManager;
        this.#connection = connection;
        this.#config = config;
        this.#provider = provider ?? this.#connection.provider;
    }
    /**
     * Deploys the given Ignition module and returns the results of the module as
     * Ethers contract instances.
     *
     * @param ignitionModule - The Ignition module to deploy.
     * @param options - The options to use for the deployment.
     * @returns Ethers contract instances for each contract returned by the
     * module.
     */
    async deploy(ignitionModule, { parameters = {}, config: perDeployConfig = {}, defaultSender = undefined, strategy, strategyConfig, deploymentId: givenDeploymentId = undefined, displayUi = false, } = {
        parameters: {},
        config: {},
        defaultSender: undefined,
        strategy: undefined,
        strategyConfig: undefined,
        deploymentId: undefined,
        displayUi: undefined,
    }) {
        if (this.#mutex) {
            throw new HardhatError(HardhatError.ERRORS.IGNITION.DEPLOY.ALREADY_IN_PROGRESS);
        }
        this.#mutex = true;
        try {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- eth_accounts returns a string array
            const accounts = (await this.#connection.provider.request({
                method: "eth_accounts",
            }));
            const artifactResolver = new HardhatArtifactResolver(this.#artifactsManager);
            const resolvedConfig = {
                ...this.#config,
                ...perDeployConfig,
            };
            const resolvedStrategyConfig = this.#resolveStrategyConfig(this.#hardhatConfig, strategy, strategyConfig);
            const chainId = Number(await this.#connection.provider.request({
                method: "eth_chainId",
            }));
            const deploymentId = resolveDeploymentId(givenDeploymentId, chainId);
            const deploymentDir = this.#connection.networkConfig.type === "edr-simulated"
                ? undefined
                : path.join(this.#hardhatConfig.paths.ignition, "deployments", deploymentId);
            const executionEventListener = displayUi
                ? new PrettyEventHandler()
                : undefined;
            let deploymentParameters;
            if (typeof parameters === "string") {
                deploymentParameters = await readDeploymentParameters(parameters);
            }
            else {
                deploymentParameters = parameters;
            }
            const result = await deploy({
                config: resolvedConfig,
                provider: this.#provider,
                deploymentDir,
                executionEventListener,
                artifactResolver,
                ignitionModule,
                deploymentParameters,
                accounts,
                defaultSender,
                strategy,
                strategyConfig: resolvedStrategyConfig,
                maxFeePerGasLimit: this.#connection.networkConfig?.ignition.maxFeePerGasLimit,
                maxPriorityFeePerGas: this.#connection.networkConfig?.ignition.maxPriorityFeePerGas,
            });
            if (result.type !== DeploymentResultType.SUCCESSFUL_DEPLOYMENT) {
                const message = errorDeploymentResultToExceptionMessage(result);
                throw new HardhatError(HardhatError.ERRORS.IGNITION.INTERNAL.DEPLOYMENT_ERROR, {
                    message,
                });
            }
            return await this.#toEthersContracts(this.#connection, ignitionModule, result);
        }
        finally {
            this.#mutex = false;
        }
    }
    async #toEthersContracts(connection, ignitionModule, result) {
        return Object.fromEntries(await Promise.all(Object.entries(ignitionModule.results).map(async ([name, contractFuture]) => [
            name,
            await this.#getContract(connection, contractFuture, result.contracts[contractFuture.id]),
        ])));
    }
    async #getContract(connection, future, deployedContract) {
        assertHardhatInvariant(isContractFuture(future), `Expected contract future but got ${future.id} with type ${future.type} instead`);
        if ("artifact" in future) {
            return connection.ethers.getContractAt(
            // The abi meets the abi spec and we assume we can convert to
            // an acceptable Ethers abi
            future.artifact.abi, deployedContract.address);
        }
        return connection.ethers.getContractAt(future.contractName, deployedContract.address);
    }
    #resolveStrategyConfig(hardhatConfig, strategyName, strategyConfig) {
        if (strategyName === undefined) {
            return undefined;
        }
        if (strategyConfig === undefined) {
            const fromHardhatConfig = hardhatConfig.ignition?.strategyConfig?.[strategyName];
            return fromHardhatConfig;
        }
        return strategyConfig;
    }
}
//# sourceMappingURL=ethers-ignition-helper.js.map